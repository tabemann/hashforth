\ Copyright (c) 2018-2019, Travis Bemann
\ All rights reserved.
\ 
\ Redistribution and use in source and binary forms, with or without
\ modification, are permitted provided that the following conditions are met:
\ 
\ 1. Redistributions of source code must retain the above copyright notice,
\    this list of conditions and the following disclaimer.
\ 
\ 2. Redistributions in binary form must reproduce the above copyright notice,
\    this list of conditions and the following disclaimer in the documentation
\    and/or other materials provided with the distribution.
\ 
\ 3. Neither the name of the copyright holder nor the names of its
\    contributors may be used to endorse or promote products derived from
\    this software without specific prior written permission.
\ 
\ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
\ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
\ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
\ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
\ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
\ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
\ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
\ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
\ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
\ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
\ POSSIBILITY OF SUCH DAMAGE.

GET-ORDER GET-CURRENT BASE @

DECIMAL
FORTH-WORDLIST 1 SET-ORDER
FORTH-WORDLIST SET-CURRENT

\ REQUIRE buffer.fs

WORDLIST CONSTANT HASHFORTH-WORDLIST
WORDLIST CONSTANT HASHFORTH-ASM-WORDLIST

FORTH-WORDLIST BUFFER-WORDLIST HASHFORTH-WORDLIST 3 SET-ORDER
HASHFORTH-WORDLIST SET-CURRENT

VARIABLE HEADER-BUFFER
VARIABLE CODE-BUFFER
VARIABLE STORAGE-BUFFER

0 CONSTANT CELL-16
1 CONSTANT CELL-32
2 CONSTANT CELL-64

0 CONSTANT TOKEN-8-16
1 CONSTANT TOKEN-16
2 CONSTANT TOKEN-16-32
3 CONSTANT TOKEN-32

VARIABLE TARGET-CELL CELL-64 TARGET-CELL !
VARIABLE TARGET-TOKEN TOKEN-32 TARGET-TOKEN !
VARIABLE MEM-SIZE 0 MEM-SIZE !
VARIABLE MAX-WORD-COUNT 0 MAX-WORD-COUNT !
VARIABLE MAX-RETURN-STACK-COUNT 0 MAX-RETURN-STACK-COUNT !

: HEADER-8, ( value -- )
  $FF AND HEADER-BUFFER @ APPEND-BYTE-BUFFER ;

: HEADER-16, ( value -- )
  $FFFF AND HERE H! HERE 2 HEADER-BUFFER @ APPEND-BUFFER ;

: HEADER-32, ( value -- )
  $FFFFFFFF AND HERE W! HERE 4 HEADER-BUFFER @ APPEND-BUFFER ;

: HEADER-64, ( value -- )
  HERE ! HERE CELL-SIZE HEADER-BUFFER @ APPEND-BUFFER ;

: HEADER, ( value -- )
  TARGET-CELL @ CASE
    CELL-16 OF HEADER-16, ENDOF
    CELL-32 OF HEADER-32, ENDOF
    CELL-64 OF HEADER-64, ENDOF
  ENDCASE ;

: HEADER-ARRAY, ( c-addr bytes -- ) HEADER-BUFFER @ APPEND-BUFFER ;

: SET-DATA ( c-addr bytes -- ) CODE-BUFFER @ APPEND-BUFFER ;

: SET-FILL-DATA ( bytes c -- )
  OVER ALLOCATE! DUP 3 PICK 3 ROLL FILL TUCK SWAP SET-DATA FREE! ;

: SET-CELL-DATA ( x -- ) HERE ! HERE CELL-SIZE SET-DATA ;

VARIABLE NAME-TABLE-OFFSET
VARIABLE INFO-TABLE-OFFSET

BEGIN-STRUCTURE NAME-TABLE-ENTRY-SIZE
  FIELD: NAME-OFFSET
  FIELD: NAME-LENGTH
END-STRUCTURE

BEGIN-STRUCTURE INFO-TABLE-ENTRY-SIZE
  FIELD: INFO-FLAGS
  FIELD: INFO-NEXT
END-STRUCTURE

: INIT-ASM
  ( cell-type token-type mem-size max-word-count max-return-stack-count -- )
  HEADER-BUFFER @ IF
    HEADER-BUFFER @ CLEAR-BUFFER
  ELSE
    65536 NEW-BUFFER HEADER-BUFFER !
  THEN
  CODE-BUFFER @ IF
    CODE-BUFFER @ CLEAR-BUFFER
  ELSE
    1024 1024 * NEW-BUFFER CODE-BUFFER !
  THEN
  STORAGE-BUFFER @ IF
    STORAGE-BUFFER @ CLEAR-BUFFER
  ELSE
    65536 NEW-BUFFER STORAGE-BUFFER !
  THEN
  MAX-RETURN-STACK-COUNT ! MAX-WORD-COUNT ! MEM-SIZE ! TARGET-TOKEN !
  TARGET-CELL !
  TARGET-CELL @ HEADER-8, TARGET-TOKEN @ HEADER-8, MEM-SIZE @ HEADER,
  MAX-WORD-COUNT @ HEADER, MAX-RETURN-STACK-COUNT @ HEADER,
  MAX-WORD-COUNT @ NAME-TABLE-ENTRY-SIZE * 0 SET-FILL-DATA
  MAX-WORD-COUNT @ INFO-TABLE-ENTRY-SIZE * 0 SET-FILL-DATA
  0 NAME-TABLE-OFFSET !
  MAX-WORD-COUNT @ NAME-TABLE-ENTRY-SIZE * INFO-TABLE-OFFSET ! ;

CELL-64 TOKEN-16-32 1024 1024 * 16 * 16384 1024 INIT-ASM

: TARGET-CELL-SIZE ( -- bytes )
  TARGET-CELL @ CASE
    CELL-16 OF 2 ENDOF
    CELL-32 OF 4 ENDOF
    CELL-64 OF 8 ENDOF
  ENDCASE ;

: TARGET-HALF-TOKEN-SIZE ( -- bytes )
  TARGET-TOKEN @ CASE
    TOKEN-8-16 OF 1 ENDOF
    TOKEN-16 OF 2 ENDOF
    TOKEN-16-32 OF 2 ENDOF
    TOKEN-32 OF 4 ENDOF
  ENDCASE ;

: TARGET-FULL-TOKEN-SIZE ( -- bytes )
  TARGET-TOKEN @ CASE
    TOKEN-8-16 OF 2 ENDOF
    TOKEN-16 OF 2 ENDOF
    TOKEN-16-32 OF 4 ENDOF
    TOKEN-32 OF 4 ENDOF
  ENDCASE ;

: TOKEN-8-16, ( token -- )
  DUP $7F > IF
    DUP $FF AND $80 OR CODE-BUFFER @ APPEND-BYTE-BUFFER
    7 RSHIFT 1- $FF AND CODE-BUFFER @ APPEND-BYTE-BUFFER
  ELSE
    CODE-BUFFER @ APPEND-BYTE-BUFFER
  THEN ;

: TOKEN-16, ( token -- )
  $FFFF AND HERE H! HERE 2 CODE-BUFFER @ APPEND-BUFFER ;

: TOKEN-16-32, ( token -- )
  DUP $7FFF > IF
    DUP $FFFF AND $8000 OR HERE H! HERE 2
    CODE-BUFFER @ APPEND-BUFFER
    15 RSHIFT 1- $FFFF AND HERE H! HERE 2
    CODE-BUFFER @ APPEND-BUFFER
  ELSE
    HERE H! HERE 2 CODE-BUFFER @ APPEND-BUFFER
  THEN ;

: TOKEN-32, ( token -- )
  $FFFFFFFF AND HERE W! HERE 4 CODE-BUFFER @ APPEND-BUFFER ;

: TOKEN, ( token -- )
\  cr ." compiling token: " dup .
  TARGET-TOKEN @ CASE
    TOKEN-8-16 OF TOKEN-8-16, ENDOF
    TOKEN-16 OF TOKEN-16, ENDOF
    TOKEN-16-32 OF TOKEN-16-32, ENDOF
    TOKEN-32 OF TOKEN-32, ENDOF
  ENDCASE ;

: ARG-16, ( value -- )
  $FFFF AND HERE H! HERE 2 CODE-BUFFER @ APPEND-BUFFER ;

: ARG-32, ( value -- )
  $FFFFFFFF AND HERE W! HERE 4 CODE-BUFFER @ APPEND-BUFFER ;

: ARG-64, ( value -- )
  HERE ! HERE CELL-SIZE CODE-BUFFER @ APPEND-BUFFER ;

: ARG, ( value -- )
  TARGET-CELL @ CASE
    CELL-16 OF ARG-16, ENDOF
    CELL-32 OF ARG-32, ENDOF
    CELL-64 OF ARG-64, ENDOF
  ENDCASE ;

: SET-ARG-16 ( value offset -- )
  SWAP $FFFF AND HERE H! HERE 2 ROT CODE-BUFFER @ WRITE-BUFFER ;

: SET-ARG-32 ( value offset -- )
  SWAP $FFFFFFFF AND HERE W! HERE 4 ROT CODE-BUFFER @ WRITE-BUFFER ;

: SET-ARG-64 ( value offset -- )
  SWAP HERE ! HERE CELL-SIZE ROT CODE-BUFFER @ WRITE-BUFFER ;

: SET-ARG ( value offset -- )
  TARGET-CELL @ CASE
    CELL-16 OF SET-ARG-16 ENDOF
    CELL-32 OF SET-ARG-32 ENDOF
    CELL-64 OF SET-ARG-64 ENDOF
  ENDCASE ;

VARIABLE CURRENT-TOKEN 56 CURRENT-TOKEN !

: NEXT-TOKEN ( -- token ) CURRENT-TOKEN @ DUP 1+ CURRENT-TOKEN ! ;

0 CONSTANT HEADERS-END
1 CONSTANT COLON-WORD
2 CONSTANT CREATE-WORD

: GET-REF ( -- ref ) CODE-BUFFER @ GET-BUFFER-LENGTH ;

: SET-NAME-INFO ( addr bytes token flags -- )
\   3 pick 3 pick type ." : " over (.) cr
  GET-REF HERE NAME-OFFSET ! 2 PICK HERE NAME-LENGTH !
  HERE NAME-TABLE-ENTRY-SIZE
  3 PICK NAME-TABLE-ENTRY-SIZE * NAME-TABLE-OFFSET @ +
  CODE-BUFFER @ WRITE-BUFFER
  HERE INFO-FLAGS ! DUP DUP 0> IF 1- THEN HERE INFO-NEXT !
  HERE INFO-TABLE-ENTRY-SIZE
  ROT INFO-TABLE-ENTRY-SIZE * INFO-TABLE-OFFSET @ +
  CODE-BUFFER @ WRITE-BUFFER
  SET-DATA ;

: MAKE-COLON-WORD ( token name-addr name-length flags -- )
  COLON-WORD HEADER-8, 3 PICK HEADER, OVER GET-REF + HEADER, 3 ROLL SWAP
  SET-NAME-INFO ;

: MAKE-CREATE-WORD ( token name-addr name-length flags -- )
  CREATE-WORD HEADER-8, 3 PICK HEADER, OVER GET-REF + HEADER, 3 ROLL SWAP
  SET-NAME-INFO ;

: MAKE-CREATE-WORD-WITH-OFFSET ( token name-addr name-length flags offset -- )
  CREATE-WORD HEADER-8, 4 PICK HEADER, HEADER, 3 ROLL SWAP
  SET-NAME-INFO ;

: END-HEADERS ( -- )
  HEADERS-END HEADER-8, CODE-BUFFER @ GET-BUFFER-LENGTH HEADER, ;

: X-UNABLE-TO-OPEN SPACE ." unable to open file" CR ;
: X-UNABLE-TO-WRITE SPACE ." unable to write to file" CR ;

256 NEW-BUFFER CONSTANT BACKUP-NAME-BUFFER

: GET-BACKUP-NAME ( name-addr name-length -- backup-addr backup-length )
  0 BEGIN
    BACKUP-NAME-BUFFER @ CLEAR-BUFFER
    2 PICK 2 PICK BACKUP-NAME-BUFFER @ APPEND-BUFFER
    [CHAR] . BACKUP-NAME-BUFFER @ APPEND-BYTE-BUFFER
    DUP BASE @ >R 10 BASE ! FORMAT-UNSIGNED
    BACKUP-NAME-BUFFER @ APPEND-BUFFER R> BASE !
    BACKUP-NAME-BUFFER @ GET-BUFFER OPEN-RDONLY /444 OPEN 0 <> IF
      CLOSE DROP 1 + FALSE
    ELSE
      2DROP 2DROP BACKUP-NAME-BUFFER @ GET-BUFFER  TRUE
    THEN
  UNTIL ;

: BACKUP-FILE ( name-addr name-length -- )
  1024 NEW-BUFFER 2 PICK 2 PICK 2 PICK READ-FILE-INTO-BUFFER 0 <> IF
    ROT ROT GET-BACKUP-NAME
    OPEN-WRONLY OPEN-CREAT OR OPEN-TRUNC OR /666 OPEN 0 <> IF
      OVER GET-BUFFER 2 PICK WAIT-WRITE-FULL 0 <> IF
        DROP CLOSE DROP DESTROY-BUFFER
      ELSE
        DROP DROP DESTROY-BUFFER ['] X-UNABLE-TO-WRITE ?RAISE
      THEN
    ELSE
      DROP DESTROY-BUFFER ['] X-UNABLE-TO-OPEN ?RAISE
    THEN
  ELSE
    DESTROY-BUFFER 2DROP
  THEN ;

: WRITE-ASM-TO-FILE ( name-addr name-length -- )
  2DUP BACKUP-FILE
  END-HEADERS OPEN-WRONLY OPEN-CREAT OR OPEN-TRUNC OR /666 OPEN
  AVERTS X-UNABLE-TO-OPEN
  HEADER-BUFFER @ GET-BUFFER 2 PICK
  WAIT-WRITE-FULL AVERTS X-UNABLE-TO-WRITE DROP
  CODE-BUFFER @ GET-BUFFER 2 PICK
  WAIT-WRITE-FULL AVERTS X-UNABLE-TO-WRITE DROP
  STORAGE-BUFFER @ GET-BUFFER 2 PICK
  WAIT-WRITE-FULL AVERTS X-UNABLE-TO-WRITE DROP
  CLOSE DROP ;

: X-UNABLE-TO-READ SPACE ." unable to read file" CR ;

: ADD-SOURCE-TO-STORAGE ( name-addr name-length -- )
  1024 NEW-BUFFER ROT ROT 2 PICK READ-FILE-INTO-BUFFER 0 <> IF
    DUP GET-BUFFER STORAGE-BUFFER @ APPEND-BUFFER
  ELSE
    DESTROY-BUFFER ['] X-UNABLE-TO-READ ?RAISE
  THEN
  STORAGE-BUFFER @ GET-BUFFER-LENGTH 0 > IF
    STORAGE-BUFFER @ GET-BUFFER 1- + C@ NEWLINE <> IF
      NEWLINE STORAGE-BUFFER @ APPEND-BYTE-BUFFER
    THEN
  THEN ;

0 CONSTANT NO-FLAG
1 CONSTANT IMMEDIATE-FLAG
2 CONSTANT COMPILE-ONLY-FLAG
4 CONSTANT HIDDEN-FLAG

: 3DUP ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 ) 2 PICK 2 PICK 2 PICK ;

\ : CREATE-COMPILE ( c-addr bytes token -- )
\   OVER 1+ NEW-BUFFER [CHAR] . OVER APPEND-BYTE-BUFFER 3 ROLL 3 ROLL 2 PICK
\   APPEND-BUFFER DUP GET-BUFFER CREATE-WITH-NAME SWAP , DESTROY-BUFFER
\   DOES> @ TOKEN, ;

: CREATE-COMPILE ( c-addr bytes token -- )
  ROT ROT CREATE-WITH-NAME , DOES> @ TOKEN, ;

: CREATE-TOKEN-LIT ( c-addr bytes token -- )
  OVER 1+ NEW-BUFFER [CHAR] & OVER APPEND-BYTE-BUFFER 3 ROLL 3 ROLL 2 PICK
  APPEND-BUFFER DUP GET-BUFFER CREATE-WITH-NAME SWAP , DESTROY-BUFFER
  DOES> 5 TOKEN, @ ARG, ;

: CREATE-TOKEN ( c-addr bytes token -- )
  OVER 1+ NEW-BUFFER [CHAR] ^ OVER APPEND-BYTE-BUFFER 3 ROLL 3 ROLL 2 PICK
  APPEND-BUFFER DUP GET-BUFFER CREATE-WITH-NAME SWAP , DESTROY-BUFFER
  DOES> @ ;

: CREATE-WORDS ( c-addr bytes token )
  3DUP CREATE-COMPILE 3DUP CREATE-TOKEN-LIT CREATE-TOKEN ;

: CREATE-TOKEN-AND-LIT-TOKEN ( c-addr bytes token )
  3DUP CREATE-TOKEN-LIT CREATE-TOKEN ;

: PRIMITIVE ( "name" token -- )
  PARSE-NAME ROT 3DUP CREATE-WORDS NO-FLAG SET-NAME-INFO ;

: PRIMITIVE-IMMEDIATE ( "name" token -- )
  PARSE-NAME ROT 3DUP CREATE-WORDS IMMEDIATE-FLAG SET-NAME-INFO ;

: PRIMITIVE-COMPILE-ONLY ( "name" token -- )
  PARSE-NAME ROT 3DUP CREATE-WORDS COMPILE-ONLY-FLAG SET-NAME-INFO ;

: PRIMITIVE-IMMEDIATE-COMPILE-ONLY ( "name" token -- )
  PARSE-NAME ROT 3DUP CREATE-WORDS IMMEDIATE-FLAG COMPILE-ONLY-FLAG OR
  SET-NAME-INFO ;

: VM FORTH-WORDLIST BUFFER-WORDLIST HASHFORTH-WORDLIST HASHFORTH-ASM-WORDLIST
  4 SET-ORDER ; IMMEDIATE

: NOT-VM HASHFORTH-ASM-WORDLIST HASHFORTH-WORDLIST BUFFER-WORDLIST
  FORTH-WORDLIST 4 SET-ORDER ; IMMEDIATE

NOT-VM HASHFORTH-ASM-WORDLIST SET-CURRENT

: DEFINE-WORD ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT
  NO-FLAG MAKE-COLON-WORD ;

: DEFINE-WORD-IMMEDIATE ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  IMMEDIATE-FLAG MAKE-COLON-WORD ;

: DEFINE-WORD-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  COMPILE-ONLY-FLAG MAKE-COLON-WORD ;

: DEFINE-WORD-IMMEDIATE-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  IMMEDIATE-FLAG COMPILE-ONLY-FLAG OR MAKE-COLON-WORD ;

: DEFINE-WORD-CREATED ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  NO-FLAG MAKE-CREATE-WORD ;

: DEFINE-WORD-CREATED-IMMEDIATE ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  IMMEDIATE-FLAG MAKE-CREATE-WORD ;

: DEFINE-WORD-CREATED-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  COMPILE-ONLY-FLAG MAKE-CREATE-WORD ;

: DEFINE-WORD-CREATED-IMMEDIATE-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  IMMEDIATE-FLAG COMPILE-ONLY-FLAG OR MAKE-CREATE-WORD ;

: DEFINE-WORD-CREATED-WITH-OFFSET ( "name" offset -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-WORDS ROT ROT 
  NO-FLAG 4 ROLL MAKE-CREATE-WORD-WITH-OFFSET ;

: NON-DEFINE-WORD ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  NO-FLAG MAKE-COLON-WORD ;

: NON-DEFINE-WORD-IMMEDIATE ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  IMMEDIATE-FLAG MAKE-COLON-WORD ;

: NON-DEFINE-WORD-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  COMPILE-ONLY-FLAG MAKE-COLON-WORD ;

: NON-DEFINE-WORD-IMMEDIATE-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  IMMEDIATE-FLAG COMPILE-ONLY-FLAG OR MAKE-COLON-WORD ;

: NON-DEFINE-WORD-CREATED ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  NO-FLAG MAKE-CREATE-WORD ;

: NON-DEFINE-WORD-CREATED-IMMEDIATE ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  IMMEDIATE-FLAG MAKE-CREATE-WORD ;

: NON-DEFINE-WORD-CREATED-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  COMPILE-ONLY-FLAG MAKE-CREATE-WORD ;

: NON-DEFINE-WORD-CREATED-IMMEDIATE-COMPILE-ONLY ( "name" -- )
  PARSE-NAME NEXT-TOKEN 3DUP CREATE-TOKEN-AND-LIT-TOKEN ROT ROT 
  IMMEDIATE-FLAG COMPILE-ONLY-FLAG OR MAKE-CREATE-WORD ;

0 PRIMITIVE END
1 PRIMITIVE NOP
2 PRIMITIVE EXIT
3 PRIMITIVE BRANCH
4 PRIMITIVE 0BRANCH
5 PRIMITIVE (LIT)
6 PRIMITIVE (DATA)
7 PRIMITIVE NEW-COLON
8 PRIMITIVE NEW-CREATE
9 PRIMITIVE SET-DOES>
10 PRIMITIVE FINISH
11 PRIMITIVE EXECUTE
12 PRIMITIVE DROP
13 PRIMITIVE DUP
14 PRIMITIVE SWAP
15 PRIMITIVE ROT
16 PRIMITIVE PICK
17 PRIMITIVE ROLL
18 PRIMITIVE @
19 PRIMITIVE !
20 PRIMITIVE C@
21 PRIMITIVE C!
22 PRIMITIVE =
23 PRIMITIVE <>
24 PRIMITIVE <
25 PRIMITIVE >
26 PRIMITIVE U<
27 PRIMITIVE U>
28 PRIMITIVE NOT
29 PRIMITIVE AND
30 PRIMITIVE OR
31 PRIMITIVE XOR
32 PRIMITIVE LSHIFT
33 PRIMITIVE RSHIFT
34 PRIMITIVE ARSHIFT
35 PRIMITIVE +
36 PRIMITIVE -
37 PRIMITIVE *
38 PRIMITIVE /
39 PRIMITIVE MOD
40 PRIMITIVE U/
41 PRIMITIVE UMOD
42 PRIMITIVE R@
43 PRIMITIVE >R
44 PRIMITIVE R>
45 PRIMITIVE SP@
46 PRIMITIVE SP!
47 PRIMITIVE RP@
48 PRIMITIVE RP!
49 PRIMITIVE >BODY
50 PRIMITIVE H@
51 PRIMITIVE H!
52 PRIMITIVE W@
53 PRIMITIVE W!
54 PRIMITIVE SET-WORD-COUNT
55 PRIMITIVE SYS

NAME-TABLE-OFFSET @ DEFINE-WORD-CREATED-WITH-OFFSET NAME-TABLE
INFO-TABLE-OFFSET @ DEFINE-WORD-CREATED-WITH-OFFSET INFO-TABLE

: END-WORD ( -- ) VM EXIT END NOT-VM ;

: LIT ( x -- ) VM (LIT) NOT-VM ARG, ;

: BACK-REF ( "name" -- ) CREATE GET-REF , DOES> @ ;

: +BRANCH-FORE ( "name" -- )
  CREATE VM BRANCH NOT-VM GET-REF , 0 ARG, DOES> @ GET-REF SWAP SET-ARG ;

: +0BRANCH-FORE ( "name" -- )
  CREATE VM 0BRANCH NOT-VM GET-REF , 0 ARG, DOES> @ GET-REF SWAP SET-ARG ;

: +BRANCH-BACK ( x -- ) VM BRANCH NOT-VM ARG, ;

: +0BRANCH-BACK ( x -- ) VM 0BRANCH NOT-VM ARG, ;

: +IF ( -- forward-ref ) VM 0BRANCH NOT-VM GET-REF 0 ARG, ;

: +ELSE ( forward-ref -- forward-ref )
  VM BRANCH NOT-VM GET-REF 0 ARG, SWAP GET-REF SWAP SET-ARG ;

: +THEN ( forward-ref -- ) GET-REF SWAP SET-ARG ;

: +BEGIN ( -- backward-ref ) GET-REF ;

: +AGAIN ( backward-ref -- ) +BRANCH-BACK ;

: +UNTIL ( backward-ref -- ) +0BRANCH-BACK ;

: +WHILE ( -- forward-ref ) VM 0BRANCH NOT-VM GET-REF 0 ARG, ;

: +REPEAT ( backward-ref forward-ref -- )
  SWAP +BRANCH-BACK GET-REF SWAP SET-ARG ;

: +DATA ( c-addr bytes -- )
  VM (DATA) NOT-VM DUP ARG, TUCK SET-DATA VM LIT NOT-VM ;

BASE ! SET-CURRENT SET-ORDER
